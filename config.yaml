general:
  project_name: "Mi Buñuelito Forecasting"
  random_state: 42
  horizon: 6
  mandatory_history_months: 36
  paths:
    raw: "data/01_raw"
    cleansed: "data/02_cleansed"
    features: "data/04_processed"
    processed: "data/04_processed"
    models: "outputs/models"
    reports: "outputs/reports"
    figures: "outputs/figures"
    experiments:
      phase_01: "experiments/phase_01_discovery/artifacts"
      phase_01A: "experiments/phase_01A_financial_audit/artifacts"
      phase_02: "experiments/phase_02_preprocessing/artifacts"

business_rules:
  ventas_diarias:
    # R1: total_unidades = precio_normal + promo_pagadas + promo_bonificadas
    total_units_sum:
      target: "total_unidades_entregadas"
      components: ["unidades_precio_normal", "unidades_promo_pagadas", "unidades_promo_bonificadas"]
    
    # R2: promo_pagadas == promo_bonificadas
    promo_balanced:
      col_pagadas: "unidades_promo_pagadas"
      col_bonificadas: "unidades_promo_bonificadas"
    
    # R3: precio >= costo
    price_viability:
      price: "precio_unitario_full"
      cost: "costo_unitario"
    
    # R4: ingresos = (normal + pagadas) * precio_full
    income_calculation:
      target: "ingresos_totales"
      base_units: ["unidades_precio_normal", "unidades_promo_pagadas"]
      unit_price: "precio_unitario_full"
    
    # R5: costo_total = unidades * costo_unitario
    cost_calculation:
      target: "costo_total"
      total_units: "total_unidades_entregadas"
      unit_cost: "costo_unitario"
    
    # R6: ingresos >= costo_total (Margen Bruto Positivo)
    profitability:
      income: "ingresos_totales"
      cost: "costo_total"
    
    # R7: utilidad = ingresos - costo
    utility_calculation:
      target: "utilidad"
      income: "ingresos_totales"
      cost: "costo_total"

    # Lógica de reconstrucción para el Preprocesador (Alias del R1)
    total_units_recalculation:
      target: "total_unidades_entregadas"
      components: ["unidades_precio_normal", "unidades_promo_pagadas", "unidades_promo_bonificadas"]

  redes_sociales:
    investment_sum:
      target: "inversion_total_diaria"
      components: ["inversion_facebook", "inversion_instagram"]

extractions:
  db_type: "supabase"
  sentinels:
    numeric: [-999, 99999, 9999, -9999]
    categorical: ["None", "NA", "null", "UNDEFINED", "N/A"]
    datetime: ["1900-01-01", "2099-12-31"]
    boolean: []
  tables:
    ventas_diarias:
      table_name: "ventas_diarias"
      date_column: "fecha"
      contract:
        fecha: "datetime"
        total_unidades_entregadas: "integer"
        unidades_precio_normal: "integer"
        unidades_promo_pagadas: "integer"
        unidades_promo_bonificadas: "integer"
        precio_unitario_full: "integer"
        costo_unitario: "float"
        ingresos_totales: "float"
        costo_total: "float"
        utilidad: "float"
    
    macro_economia:
      table_name: "macro_economia"
      date_column: "fecha"
      contract:
        fecha: "datetime"
        ipc_mensual: "float"
        trm_promedio: "float"
        tasa_desempleo: "float"
        costo_insumos_index: "float"
        confianza_consumidor: "float"

    promocion_dia:
      table_name: "promocion_dia"
      date_column: "fecha"
      contract:
        fecha: "datetime"
        es_promo: "integer"

    redes_sociales:
      table_name: "redes_sociales"
      date_column: "fecha"
      contract:
        fecha: "datetime"
        campaign: "text"
        inversion_facebook: "float"
        inversion_instagram: "float"
        inversion_total_diaria: "float"

preprocessing:
  target_variable: "total_unidades_entregadas"
  aggregation_level: "monthly"
  
  # 1 y 2. Limpieza Estructural (Atomicidad y Calidad)
  cleaning:
    # Drop inmediato: Columnas adicionales detectadas en Discovery y las que violan atomicidad
    drop_immediate:
      ventas_diarias: ["ingresos_totales", "costo_total", "utilidad", "id", "created_at"]
      macro_economia: ["id", "created_at"]
      promocion_dia: ["id", "created_at"]
      redes_sociales: ["inversion_total_diaria", "id", "created_at", "campaign"]
    
    # Columnas de soporte: Se usan para el Preprocesado y luego se eliminan (Anti-Laziness/Data Leakage)
    target_build_components: ["unidades_precio_normal", "unidades_promo_pagadas", "unidades_promo_bonificadas"]

  # 3. Blindaje Temporal (Regla de Oro)
  anti_leakage:
    active: true
    mode: "strict_closed_month"

  # 4. Gestión de Duplicados (Filas y Fechas)
  duplicates:
    strategy: "keep_last" # Regla de Oro: Conservar registro más reciente en tiempo de carga

  # 6. Reindexación e Integridad Temporal (Gaps)
  reindexing:
    frequencies:
      ventas_diarias: "D"
      promocion_dia: "D"
      redes_sociales: "D"
      macro_economia: null # Sin reindexación necesaria (frecuencia mensual nativa)

  # 7. Protocolo de Imputación por Dominio
  imputation:
    macro_economia:
      method: "ffill"
      fallback: "bfill"
    
    promocion_dia:
      relevance_year: 2022
      cycles:
        spring: {start: "04-01", end: "05-31"}
        autumn: {start: "09-01", end: "10-31"}
      default_value: 0

    redes_sociales:
      strategy_milestone: "2022-03-17"
      campaign_windows:
        - name: "Ciclo Abr-May"
          start: "03-15"
          end: "05-25"
        - name: "Ciclo Sep-Oct"
          start: "09-15"
          end: "10-25"
      default_investment: 0.0
      default_label: "No ciclo"

    ventas_diarias:
      units:
        method: "ffill"
        fallback: "bfill"
      financials:
        price_col: "precio_unitario_full"
        cost_col: "costo_unitario"
        strategy: "monthly_mode"

eda:
  # 1. Temporal Partitioning (Rule 3.1)
  partitioning:
    test_size: 12
    val_size: 12
    random_state: 42
  
  # 2. Analysis Levels (Rule 3.3)
  analysis_levels: ["month", "quarter", "semester", "year"]
  
  # 3. Time Series Diagnostics (Rule 3.4, 3.5, 3.6)
  time_series:
    decomposition:
      model: "additive"
      period: 12
    stationarity:
      test: "adfuller"
      max_lags: null
      significance_level: 0.05
    autocorrelation:
      max_lags: 24
      alpha: 0.05
  
  # 4. Business Events Validation (Rule 3.7)
  business_events:
    pandemia:
      start: "2020-04-01"
      end: "2021-05-31"
    promociones:
      months: [4, 5, 9, 10]
    novenas:
      start_day: 16
      end_day: 23
      month: 12
    payments:
      days: [15, 30]
      bonus_months: [6, 12]

  # 5. Visualizations & Snapshot Management
  visuals:
    save_figures: true
    history_folder: "history"
    fig_size: [12, 6]
    style: "seaborn-v0_8-whitegrid"
    palette: "viridis"

features:
  # Lógica de Proyección (Regla 3.3)
  projection:
    method: "recursive_moving_average"
    window_size: 2
    columns_to_project: 
      - "ipc_mensual"
      - "confianza_consumidor"
      - "trm_promedio"
      - "tasa_desempleo"
      - "costo_insumos_index"

  # Definición de Atributos a Construir
  engineering:
    # 1. Calendario y Ciclicidad
    cyclical:
      month: {period: 12}
      quarter: {period: 4}
      semester: {period: 2}
    
    # 2. Eventos Especiales (Basado en Reglas de Negocio)
    events:
      pandemia:
        start: "2020-04-01"
        end: "2021-05-31"
      novenas:
        month: 12
        start_day: 16
        end_day: 23
        total_days: 8
      bonus_months: [6, 12] # Junio y Diciembre (Primas)
    
    # 3. Métricas de Intensidad de Tiempo
    calendar_technical:
      calculate_days_in_month: true
      calculate_weekend_days: true
      country_holidays: "Colombia" # Para holidays_count

    # 4. Tendencia
    trend:
      include_time_drift: true

  # Selección final de variables exógenas para el modelo
  exogenous_selection:
    - "month_sin"
    - "month_cos"
    - "quarter_sin"
    - "quarter_cos"
    - "is_pandemic"
    - "novenas_intensity"
    - "is_bonus_month"
    - "days_in_month"
    - "weekend_days_count"
    - "holidays_count"
    - "time_drift_index"
    - "es_promo"
    - "precio_unitario_full"
    - "ipc_mensual"
    - "confianza_consumidor"
    - "inversion_facebook"
    - "inversion_instagram"

# ==============================================================================
# 5. Parámetros GLOBALES de Entrenamiento y Experimentación (Phase 5)
# ==============================================================================
training_parameters:
  # --- Parámetros de Negocio ---
  forecast_horizon: 6
  gap: 0
  
  # --- Parámetros de Evaluación y Selección ---
  metric_for_tuning: 'mean_absolute_error'
  n_top_candidates_to_validate: 5 

  # --- Parámetros para el Grid Search de skforecast ---
  grid_search_cv_params:
    initial_train_size: null 
    steps: 6
    refit: false 
    fixed_train_size: false
    allow_incomplete_folds: true
    return_best: true
    verbose: false

  # Grillas para Grid Search
  hyperparameter_grids:
    LightGBM:
      n_estimators      : [100, 500]
      max_depth         : [5, 10]
      learning_rate     : [0.01, 0.1]
      num_leaves        : [31, 64]
      
    RandomForest:
      n_estimators      : [100, 500]
      max_depth         : [10, 20, 30, null]
      min_samples_split : [2, 10]
      
    Ridge:
      alpha: [0.1, 1.0, 10.0, 100.0]
    
    GradientBoostingRegressor:
      n_estimators      : [100, 300]
      learning_rate     : [0.01, 0.1]
      max_depth         : [3, 7]

    HistGradientBoostingRegressor:
      learning_rate     : [0.01, 0.1]
      max_iter          : [100, 300]
      max_leaf_nodes    : [20, 40]

    XGBRegressor:
      n_estimators      : [100, 500]
      learning_rate     : [0.01, 0.1]
      max_depth         : [3, 7]

# ==============================================================================
# 6. ESPACIOS DE BÚSQUEDA PARA OPTIMIZACIÓN BAYESIANA
# ==============================================================================
bayesian_search_spaces:
  XGBRegressor:
    n_estimators: ['suggest_int', 100, 1000]
    max_depth: ['suggest_int', 3, 10]
    learning_rate: ['suggest_float', 0.01, 0.2, {'log': true}]
    subsample: ['suggest_float', 0.6, 1.0]

  LightGBM:
    n_estimators: ['suggest_int', 100, 1000]
    max_depth: ['suggest_int', 5, 20]
    learning_rate: ['suggest_float', 0.01, 0.2, {'log': true}]
    num_leaves: ['suggest_int', 20, 128]
    
  RandomForest:
    n_estimators: ['suggest_int', 100, 800]
    max_depth: ['suggest_int', 10, 25]

# ==============================================================================
# 7. CONFIGURACIÓN DE MODELOS DE LÍNEA BASE (BASELINES)
# ==============================================================================
baseline_models:
  - name: 'run00_naive_baseline'
    enabled: true
    description: 'Pronóstico ingenuo estacional (X = X-12).'
    forecaster_type: 'ForecasterEquivalentDate'
    forecasting_parameters:
      offset: 12    
      n_offsets: 1      
    exogenous_features:
      features_to_use: []
    preprocessing:
      target_transform: null
      differentiation: 0

# ==============================================================================
# 8. LISTA DE EXPERIMENTOS (Hoja de Ruta del Torneo)
# ==============================================================================
experiments:
  # EXPERIMENTO 01: Solo historia (Laboratorio Técnico)
  - name: 'run01_endogenous'
    enabled: true
    description: 'Hipótesis: Calibración técnica (Dif vs Trans) usando solo el pasado de la serie.'
    models_to_train:
      - 'LightGBM'
      - 'RandomForest'
      - 'Ridge'
      - 'XGBRegressor'
    forecasting_parameters:
      type: 'ForecasterDirect'
      gap: 0
      lags_grid:
        - [1, 6]
        - [1, 2, 3, 6]
        - [1, 2, 3, 6, 12, 13]
      window_features:
        enabled: true
        stats: ['mean', 'mean', 'mean', 'std', 'std', 'std', 'max', 'max', 'max']
        window_sizes: [3, 6, 12, 3, 6, 12, 3, 6, 12]
  
  # EXPERIMENTO 02: Solo variables "nativas" del calendario
  - name: 'run02_with_calendar_features'
    enabled: true
    description: 'Hipótesis: Variables cíclicas capturan mejor la periodicidad.'
    models_to_train:
      - 'LightGBM'
      - 'RandomForest'
      - 'Ridge'
      - 'XGBRegressor'
    forecasting_parameters:
      type: 'ForecasterDirect'
      gap: 0
      lags_grid:
        - [1, 6]
        - [1, 2, 3, 6]
        - [1, 2, 3, 6, 12, 13]
      window_features:
        enabled: true
        stats: ['mean', 'mean', 'mean', 'std', 'std', 'std', 'max', 'max', 'max']
        window_sizes: [3, 6, 12, 3, 6, 12, 3, 6, 12]
    exogenous_features:
      features_to_use: ['month_sin', 'month_cos', 'quarter_sin', 'quarter_cos', 'semester_sin', 'semester_cos']

  # EXPERIMENTO 03: Calendario Nativo + Eventos/Conteo
  - name: 'run03_full_calendar_features'
    enabled: true
    description: 'Hipótesis: Calendario completo (Cíclico + Eventos como Festivos y Novenas).'
    models_to_train:
      - 'LightGBM'
      - 'RandomForest'
      - 'Ridge'
      - 'XGBRegressor'
    forecasting_parameters:
      type: 'ForecasterDirect'
      gap: 0
      lags_grid:
        - [1, 6]
        - [1, 2, 3, 6]
        - [1, 2, 3, 6, 12, 13]
      window_features:
        enabled: true
        stats: ['mean', 'mean', 'mean', 'std', 'std', 'std', 'max', 'max', 'max']
        window_sizes: [3, 6, 12, 3, 6, 12, 3, 6, 12]
    exogenous_features:
      features_to_use: ['month_sin', 'month_cos', 'quarter_sin', 'quarter_cos', 'semester_sin', 'semester_cos', 'holidays_count', 'weekend_days_count', 'is_bonus_month', 'novenas_intensity', 'days_in_month']

  # EXPERIMENTO 04: Impacto de Hitos Estructurales
  - name: 'run04_structural_evolution'
    enabled: true
    description: 'Hipótesis: El calendario completo más los hitos de COVID y tendencia temporal.'
    models_to_train:
      - 'LightGBM'
      - 'RandomForest'
      - 'Ridge'
      - 'XGBRegressor'
    forecasting_parameters:
      type: 'ForecasterDirect'
      gap: 0
      lags_grid:
        - [1, 6]
        - [1, 2, 3, 6]
        - [1, 2, 3, 6, 12, 13]
      window_features:
        enabled: true
        stats: ['mean', 'mean', 'mean', 'std', 'std', 'std', 'max', 'max', 'max']
        window_sizes: [3, 6, 12, 3, 6, 12, 3, 6, 12]
    exogenous_features:
      features_to_use: ['month_sin', 'month_cos', 'quarter_sin', 'quarter_cos', 'semester_sin', 'semester_cos', 'holidays_count', 'weekend_days_count', 'is_bonus_month', 'novenas_intensity', 'days_in_month', 'is_pandemic', 'time_drift_index', 'es_promo', 'precio_unitario_full']

  # EXPERIMENTO 05: Contexto Macroeconómico
  - name: 'run05_macro_context'
    enabled: true
    description: 'Hipótesis: Variables económicas como Inflación (IPC) y Desempleo ayudan a predecir cambios.'
    models_to_train:
      - 'LightGBM'
      - 'RandomForest'
      - 'Ridge'
      - 'XGBRegressor'
    forecasting_parameters:
      type: 'ForecasterDirect'
      gap: 0
      lags_grid:
        - [1, 6]
        - [1, 2, 3, 6]
        - [1, 2, 3, 6, 12, 13]
      window_features:
        enabled: true
        stats: ['mean', 'mean', 'mean', 'std', 'std', 'std', 'max', 'max', 'max']
        window_sizes: [3, 6, 12, 3, 6, 12, 3, 6, 12]
    exogenous_features:
      features_to_use: ['month_sin', 'month_cos', 'quarter_sin', 'quarter_cos', 'semester_sin', 'semester_cos', 'holidays_count', 'weekend_days_count', 'is_bonus_month', 'novenas_intensity', 'days_in_month', 'is_pandemic', 'time_drift_index', 'es_promo', 'precio_unitario_full', 'ipc_mensual', 'confianza_consumidor', 'trm_promedio', 'tasa_desempleo', 'costo_insumos_index']

  # EXPERIMENTO 06: Modelo Maestro Integral (Todas las variables - Sin Pesos)
  - name: 'run06_master_integral'
    enabled: true
    description: 'Hipótesis: El modelo combina todas las variables exógenas disponibles (Inversión Ads + Macro + Calendario).'
    models_to_train:
      - 'LightGBM'
      - 'RandomForest'
      - 'Ridge'
      - 'XGBRegressor'
    forecasting_parameters:
      type: 'ForecasterDirect'
      gap: 0
      lags_grid:
        - [1, 6]
        - [1, 2, 3, 6]
        - [1, 2, 3, 6, 12, 13]
      window_features:
        enabled: true
        stats: ['mean', 'mean', 'mean', 'std', 'std', 'std', 'max', 'max', 'max']
        window_sizes: [3, 6, 12, 3, 6, 12, 3, 6, 12]
    exogenous_features:
      features_to_use: 'all'

  # EXPERIMENTO FINAL: Optimización por Eras (Ponderación)
  - name: 'run_final'
    enabled: true
    description: 'Hipótesis: Aplicar pesos por etapas al mejor modelo mejora el pronóstico final (Fase Retail > Fase COVID).'
    models_to_train:
      - 'LightGBM'
      - 'RandomForest'
      - 'Ridge'
      - 'XGBRegressor'
    forecasting_parameters:
      type: 'ForecasterDirect'
      gap: 0
      lags_grid:
        - [1, 6]
        - [1, 2, 3, 6]
        - [1, 2, 3, 6, 12, 13]
      window_features:
        enabled: true
        stats: ['mean', 'mean', 'mean', 'std', 'std', 'std', 'max', 'max', 'max']
        window_sizes: [3, 6, 12, 3, 6, 12, 3, 6, 12]
    training_options:
      use_weights: true
      event_definitions:
          fase_pre_pandemia: { start_date: '2018-01-01', end_date: '2020-04-30' }
          fase_crisis_covid: { start_date: '2020-05-01', end_date: '2021-02-28' }
          fase_recuperacion: { start_date: '2021-03-01', end_date: '2022-05-31' }
          fase_retail:       { start_date: '2022-06-01', end_date: '2026-12-31' }
      weight_function_type: 'by_era' 
      weight_distribution:
        default: 0.5
        fase_pre_pandemia: 0.5
        fase_crisis_covid: 0.1
        fase_recuperacion: 0.7
        fase_retail: 1.0

